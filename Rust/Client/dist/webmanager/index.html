<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>engarde web manager</title>
  <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Crect width='100' height='100' rx='18' ry='18' fill='%230a1b33'/%3E%3Cpath fill='%237ae0ff' d='M20 72L50 18l30 54H20zm26-10h8l-4-10-4 10z'/%3E%3C/svg%3E">
  <style>
    :root {
      color-scheme: light dark;
      --bg: #0a0f1c;
      --bg-accent-1: radial-gradient(circle at 20% 20%, rgba(122,224,255,0.08), transparent 25%);
      --bg-accent-2: radial-gradient(circle at 80% 0%, rgba(123,216,143,0.06), transparent 18%);
      --bg-accent-3: radial-gradient(circle at 50% 90%, rgba(255,107,107,0.06), transparent 22%);
      --card: rgba(17,26,47,0.8);
      --panel: rgba(255,255,255,0.02);
      --text: #e6ecf9;
      --muted: #8ea0bf;
      --accent: #7ae0ff;
      --danger: #ff6b6b;
      --success: #7bd88f;
      --warning: #ffb86c;
      --border: #1c2a45;
      --shadow: 0 10px 40px rgba(0,0,0,.35);
      --toggle-bg: #1f2c45;
      --toggle-knob: #e6ecf9;
      --toggle-active: #44c1ff;
      --toggle-active-knob: #0a0f1c;
      font-family: "Inter", "Segoe UI", system-ui, -apple-system, sans-serif;
      background: var(--bg-accent-1), var(--bg-accent-2), var(--bg-accent-3), var(--bg);
      color: var(--text);
    }

    :root[data-theme="light"] {
      color-scheme: light;
      --bg: #f4f7fb;
      --bg-accent-1: radial-gradient(circle at 20% 20%, rgba(10,88,202,0.08), transparent 28%);
      --bg-accent-2: radial-gradient(circle at 80% 0%, rgba(28,155,110,0.08), transparent 20%);
      --bg-accent-3: radial-gradient(circle at 50% 90%, rgba(255,137,76,0.08), transparent 24%);
      --card: rgba(255,255,255,0.88);
      --panel: rgba(10,24,46,0.05);
      --text: #1f2a3a;
      --muted: #5a6b87;
      --accent: #0b8bd5;
      --danger: #d84b4b;
      --success: #198754;
      --warning: #c9781f;
      --border: rgba(31,42,58,0.16);
      --shadow: 0 10px 32px rgba(17,33,68,0.12);
      --toggle-bg: #d7e2f3;
      --toggle-knob: #ffffff;
      --toggle-active: #0b8bd5;
      --toggle-active-knob: #f4f7fb;
    }

    * { box-sizing: border-box; }
    body { margin: 0; min-height: 100vh; }

    .app { max-width: 1200px; margin: 0 auto; padding: 32px 18px 48px; }
    header { display: flex; flex-wrap: wrap; gap: 12px; align-items: center; justify-content: space-between; margin-bottom: 20px; }
    .title { font-size: 28px; font-weight: 800; letter-spacing: -0.02em; display: flex; gap: 8px; align-items: center; }
    .pill { background: rgba(122,224,255,0.12); color: #b9ebff; padding: 6px 10px; border-radius: 999px; font-size: 12px; border: 1px solid rgba(122,224,255,0.2); }
    .card { background: var(--card); border: 1px solid var(--border); border-radius: 16px; padding: 18px; box-shadow: var(--shadow); backdrop-filter: blur(4px); }
    .subtle { color: var(--muted); font-size: 14px; }
    .header-actions { display: flex; flex-wrap: wrap; gap: 12px; align-items: center; justify-content: flex-end; }
    .header-refresh { display: inline-flex; align-items: center; gap: 8px; }
    .header-refresh .input { width: 120px; text-align: center; }

    .grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(240px, 1fr)); gap: 14px; }
    .stat { padding: 12px 14px; border-radius: 12px; border: 1px solid var(--border); background: var(--panel); }
    .stat .label { color: var(--muted); font-size: 12px; text-transform: uppercase; letter-spacing: .06em; }
    .stat .value { font-size: 26px; font-weight: 700; }

    .btn { display: inline-flex; align-items: center; gap: 8px; padding: 10px 14px; border-radius: 12px; border: 1px solid var(--border); cursor: pointer; font-weight: 600; background: linear-gradient(120deg, rgba(122,224,255,0.2), rgba(122,224,255,0.08)); color: var(--text); transition: transform .15s, border-color .15s, background .15s; text-decoration: none; }
    .btn:hover { transform: translateY(-1px); border-color: rgba(122,224,255,0.7); }
    .btn.secondary { background: transparent; color: var(--text); }
    .btn.danger { background: rgba(255,107,107,0.12); color: #ffd6d6; border-color: rgba(255,107,107,0.3); }

    .switch { display: inline-flex; align-items: center; gap: 10px; cursor: pointer; user-select: none; }
    .switch input { display: none; }
    .toggle { width: 46px; height: 24px; background: var(--toggle-bg); border-radius: 999px; position: relative; transition: background .2s; border: 1px solid var(--border); }
    .toggle::after { content: ""; width: 18px; height: 18px; background: var(--toggle-knob); border-radius: 50%; position: absolute; top: 50%; left: 4px; transform: translateY(-50%); transition: transform .2s, background .2s; box-shadow: 0 2px 10px rgba(0,0,0,.3); }
    .switch input:checked + .toggle { background: var(--toggle-active); }
    .switch input:checked + .toggle::after { transform: translate(20px, -50%); background: var(--toggle-active-knob); }

    .input { background: rgba(255,255,255,0.04); border: 1px solid var(--border); border-radius: 12px; padding: 10px 12px; color: var(--text); width: 100%; font-size: 14px; }
    .input:focus { outline: 2px solid rgba(122,224,255,0.4); }
    .range { accent-color: #7ae0ff; width: 120px; }

    .interface-columns { display: grid; grid-template-columns: repeat(auto-fit, minmax(240px, 1fr)); gap: 16px; margin-top: 12px; }
    .interface-box { border-radius: 16px; border: 1px solid var(--border); padding: 14px; background: var(--panel); min-height: 220px; display: flex; flex-direction: column; gap: 12px; }
    .interface-box.active { border-color: rgba(123,216,143,0.45); }
    .interface-box.inactive { border-color: rgba(255,184,108,0.45); }
    .interface-box.excluded { border-color: rgba(255,107,107,0.45); }
    .box-header { display: flex; align-items: center; justify-content: space-between; gap: 10px; }
    .box-title { font-size: 14px; font-weight: 700; text-transform: uppercase; letter-spacing: .08em; color: var(--muted); }
    .interface-list { display: grid; gap: 10px; }
    .iface-card { padding: 12px; border-radius: 12px; border: 1px solid var(--border); background: var(--card); display: grid; gap: 6px; animation: floatIn .25s ease; transition: transform .2s ease, box-shadow .2s ease; }
    .iface-card .row { display: flex; justify-content: space-between; gap: 8px; font-size: 13px; }
    .iface-card .label { color: var(--muted); font-size: 12px; text-transform: uppercase; letter-spacing: .06em; }
    .iface-card .value { font-weight: 600; }
    .iface-traffic { display: inline-flex; align-items: center; gap: 6px; font-weight: 700; color: var(--accent); }
    .iface-actions { display: flex; gap: 8px; flex-wrap: wrap; }
    .iface-actions .btn { padding: 6px 10px; font-size: 12px; border-radius: 10px; }

    @keyframes floatIn {
      from { opacity: 0; transform: translateY(8px); }
      to { opacity: 1; transform: translateY(0); }
    }
    .status { display: inline-flex; align-items: center; gap: 8px; padding: 6px 10px; border-radius: 999px; font-weight: 700; font-size: 12px; text-transform: uppercase; letter-spacing: .04em; }
    .status.active { background: rgba(123,216,143,0.14); color: var(--success); border: 1px solid rgba(123,216,143,0.35); }
    .status.idle { background: rgba(255,184,108,0.14); color: var(--warning); border: 1px solid rgba(255,184,108,0.35); }
    .status.excluded { background: rgba(255,107,107,0.14); color: var(--danger); border: 1px solid rgba(255,107,107,0.35); }
    .chip { display: inline-flex; align-items: center; gap: 6px; padding: 6px 10px; border-radius: 10px; background: rgba(255,255,255,0.04); color: var(--text); border: 1px solid var(--border); }

    .badge { padding: 4px 10px; border-radius: 999px; border: 1px solid var(--border); color: var(--muted); }
    .ping-section { display: grid; gap: 16px; }
    .ping-header { display: flex; justify-content: space-between; align-items: center; gap: 10px; flex-wrap: wrap; }
    .ping-grid { display: grid; grid-template-columns: minmax(0, 1fr) minmax(220px, 320px); gap: 16px; }
    .ping-chart { position: relative; border-radius: 14px; border: 1px solid var(--border); background: rgba(0,0,0,0.12); padding: 14px; min-height: 220px; }
    .ping-chart canvas { width: 100%; height: 100%; display: block; }
    .ping-overlay { position: absolute; inset: 0; display: flex; align-items: center; justify-content: center; color: var(--muted); font-size: 14px; }
    .ping-tooltip { position: absolute; pointer-events: none; padding: 8px 10px; border-radius: 10px; background: rgba(10,15,28,0.92); border: 1px solid rgba(255,255,255,0.12); color: var(--text); font-size: 12px; box-shadow: var(--shadow); transform: translate(-50%, -120%); opacity: 0; transition: opacity .1s ease; white-space: nowrap; }
    :root[data-theme="light"] .ping-tooltip { background: rgba(244,247,251,0.95); }
    .ping-stats { display: grid; gap: 10px; }
    .ping-stat { border-radius: 12px; border: 1px solid var(--border); background: var(--panel); padding: 12px; display: flex; align-items: center; justify-content: space-between; gap: 10px; }
    .ping-stat span { color: var(--muted); font-size: 12px; text-transform: uppercase; letter-spacing: .06em; }
    .ping-stat strong { font-size: 18px; font-weight: 700; }
    .metrics-panel { display: flex; flex-wrap: wrap; gap: 10px; align-items: center; justify-content: flex-end; }
    .metric-toggle { display: inline-flex; align-items: center; gap: 8px; padding: 6px 10px; border-radius: 999px; border: 1px solid var(--border); background: rgba(255,255,255,0.04); font-size: 12px; cursor: pointer; }
    .metric-toggle input { margin: 0; }
    .metric-swatch { width: 10px; height: 10px; border-radius: 50%; background: var(--swatch, var(--accent)); display: inline-block; }
    .traffic-grid { display: grid; grid-template-columns: minmax(0, 1fr); gap: 16px; }
    .traffic-chart { position: relative; border-radius: 14px; border: 1px solid var(--border); background: rgba(0,0,0,0.12); padding: 14px; min-height: 220px; }
    .traffic-chart canvas { width: 100%; height: 100%; display: block; }
    .traffic-overlay { position: absolute; inset: 0; display: flex; align-items: center; justify-content: center; color: var(--muted); font-size: 14px; }
    .traffic-tooltip { position: absolute; pointer-events: none; padding: 8px 10px; border-radius: 10px; background: rgba(10,15,28,0.92); border: 1px solid rgba(255,255,255,0.12); color: var(--text); font-size: 12px; box-shadow: var(--shadow); transform: translate(-50%, -120%); opacity: 0; transition: opacity .1s ease; white-space: nowrap; }
    :root[data-theme="light"] .traffic-tooltip { background: rgba(244,247,251,0.95); }
    .traffic-log { display: grid; gap: 8px; }
    .log-list { display: grid; gap: 8px; max-height: 220px; overflow-y: auto; padding-right: 6px; }
    .log-entry { border-radius: 12px; border: 1px solid var(--border); background: var(--panel); padding: 10px 12px; display: grid; gap: 6px; font-size: 12px; }
    .log-entry .log-time { font-weight: 700; color: var(--text); }
    .log-entry .log-line { color: var(--muted); display: flex; flex-wrap: wrap; gap: 6px; }
    .log-chip { border-radius: 999px; padding: 2px 8px; border: 1px solid var(--border); background: rgba(255,255,255,0.04); color: var(--text); }

    @media (max-width: 700px) {
      header { flex-direction: column; align-items: flex-start; }
      .controls { grid-template-columns: 1fr; }
      th:nth-child(3), td:nth-child(3), th:nth-child(5), td:nth-child(5) { display: none; }
      .ping-grid { grid-template-columns: 1fr; }
    }
  </style>
</head>
<body>
  <div class="app">
    <header>
      <div class="title">engarde web manager <span class="pill">NG-UI</span></div>
      <div class="header-actions">
        <label class="switch" aria-label="Enable dark theme">
          <input type="checkbox" id="themeToggle">
          <span class="toggle"></span>
          <span>Dark theme</span>
        </label>
        <div class="header-refresh" aria-label="Auto-refresh">
          <input class="input" id="intervalInput" type="text" inputmode="numeric" placeholder="2s-60s">
          <button class="btn secondary" id="applyInterval" type="button">Apply</button>
        </div>
      </div>
    </header>

    <section class="grid" id="metaCards">
      <div class="card stat">
        <div class="label">Version</div>
        <div class="value" id="version">—</div>
      </div>
      <div class="card stat">
        <div class="label">Description</div>
        <div class="value" id="description">—</div>
      </div>
      <div class="card stat">
        <div class="label">Listen address</div>
        <div class="value" id="listenAddress">—</div>
      </div>
    </section>

    <section class="grid" style="margin-top: 16px;">
      <div class="card stat">
        <div class="label">Active interfaces</div>
        <div class="value" id="activeCount">0</div>
        <div class="subtle">Currently routed through WireGuard</div>
      </div>
      <div class="card stat">
        <div class="label">Excluded interfaces</div>
        <div class="value" id="excludedCount">0</div>
        <div class="subtle">Ignored by transmission</div>
      </div>
      <div class="card stat">
        <div class="label">Inactive interfaces</div>
        <div class="value" id="idleCount">0</div>
        <div class="subtle">No recent traffic</div>
      </div>
    </section>

    <section class="card" style="margin-top: 16px;">
      <div style="display:flex; justify-content:space-between; align-items:center; gap:10px; flex-wrap:wrap;">
        <div>
          <div class="subtle" style="text-transform:uppercase; letter-spacing:.08em;">Interfaces</div>
          <h3 style="margin:4px 0 0;">Real-time monitoring</h3>
        </div>
        <div class="badge">Sort by: <span id="sortLabel">name ↑</span></div>
      </div>
      <div class="interface-columns">
        <div class="interface-box active">
          <div class="box-header">
            <div class="box-title">Active</div>
            <span class="badge" id="activeBadge">0</span>
          </div>
          <div class="interface-list" id="activeList"></div>
        </div>
        <div class="interface-box inactive">
          <div class="box-header">
            <div class="box-title">Inactive</div>
            <span class="badge" id="inactiveBadge">0</span>
          </div>
          <div class="interface-list" id="inactiveList"></div>
        </div>
        <div class="interface-box excluded">
          <div class="box-header">
            <div class="box-title">Excluded</div>
            <span class="badge" id="excludedBadge">0</span>
          </div>
          <div class="interface-list" id="excludedList"></div>
        </div>
      </div>
    </section>

    <section class="card ping-section" style="margin-top: 16px;">
      <div class="ping-header">
        <div>
          <div class="subtle" style="text-transform:uppercase; letter-spacing:.08em;">WireGuard ping</div>
          <h3 style="margin:4px 0 0;">Tunnel health (last 3 min)</h3>
        </div>
        <div class="metrics-panel" id="pingMetricsPanel">
          <label class="metric-toggle">
            <input type="checkbox" data-metric="latency" checked>
            <span class="metric-swatch" style="--swatch: rgba(122,224,255,0.9);"></span>
            Latency
          </label>
          <label class="metric-toggle">
            <input type="checkbox" data-metric="loss" checked>
            <span class="metric-swatch" style="--swatch: rgba(255,107,107,0.8);"></span>
            Loss markers
          </label>
          <div class="chip">Target: <span id="pingTarget">—</span></div>
        </div>
      </div>
      <div class="ping-grid">
        <div class="ping-chart">
          <canvas id="pingChart"></canvas>
          <div class="ping-overlay" id="pingEmpty">Waiting for samples…</div>
          <div class="ping-tooltip" id="pingTooltip"></div>
        </div>
        <div class="ping-stats">
          <div class="ping-stat"><span>Avg ping</span><strong id="pingAvg">—</strong></div>
          <div class="ping-stat"><span>Min ping</span><strong id="pingMin">—</strong></div>
          <div class="ping-stat"><span>Max ping</span><strong id="pingMax">—</strong></div>
          <div class="ping-stat"><span>Packet loss</span><strong id="pingLoss">—</strong></div>
          <div class="ping-stat"><span>Lost packets</span><strong id="pingLost">—</strong></div>
        </div>
      </div>
      <div class="subtle">Sampling every 250ms • Rolling window of 3 minutes</div>
    </section>

    <section class="card traffic-section" style="margin-top: 16px;">
      <div class="ping-header">
        <div>
          <div class="subtle" style="text-transform:uppercase; letter-spacing:.08em;">Throughput</div>
          <h3 style="margin:4px 0 0;">Connection speeds (last 3 min)</h3>
        </div>
        <div class="metrics-panel" id="trafficMetrics"></div>
      </div>
      <div class="traffic-grid">
        <div class="traffic-chart">
          <canvas id="trafficChart"></canvas>
          <div class="traffic-overlay" id="trafficEmpty">Waiting for traffic samples…</div>
          <div class="traffic-tooltip" id="trafficTooltip"></div>
        </div>
      </div>
      <div class="traffic-log">
        <div class="subtle" style="text-transform:uppercase; letter-spacing:.08em;">Traffic log</div>
        <div class="log-list" id="trafficLog"></div>
      </div>
    </section>

  </div>

  <script>
    const DEMO_MODE = new URLSearchParams(location.search).has('demo');
    const state = {
      data: null,
      auto: true,
      interval: 3000,
      timer: null,
      pingTimer: null,
      sort: { key: 'name', dir: 'asc' },
      pingMetrics: { latency: true, loss: true },
      traffic: {
        windowMs: 180000,
        samples: [],
        metrics: { tunnel: true, interfaces: {} },
        colors: {}
      },
      trafficLog: []
    };

    const qs = (id) => document.getElementById(id);
    const pingCanvas = qs('pingChart');
    const pingEmpty = qs('pingEmpty');
    const pingTooltip = qs('pingTooltip');
    const trafficCanvas = qs('trafficChart');
    const trafficEmpty = qs('trafficEmpty');
    const trafficTooltip = qs('trafficTooltip');
    const trafficMetrics = qs('trafficMetrics');
    const trafficLog = qs('trafficLog');
    const themeToggle = qs('themeToggle');
    const storedTheme = localStorage.getItem('engardeTheme');
    const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
    const initialTheme = storedTheme || (prefersDark ? 'dark' : 'light');

    const applyTheme = (theme) => {
      document.documentElement.dataset.theme = theme;
      themeToggle.checked = theme === 'dark';
      localStorage.setItem('engardeTheme', theme);
    };

    applyTheme(initialTheme);
    themeToggle.addEventListener('change', () => {
      applyTheme(themeToggle.checked ? 'dark' : 'light');
    });
    function humanizeLast(sec) {
      if (sec === null || sec === undefined) return '—';
      if (sec < 5) return 'just now';
      if (sec < 60) return `${sec}s ago`;
      const m = Math.floor(sec / 60);
      if (m < 60) return `${m}m ago`;
      const h = Math.floor(m / 60);
      return `${h}h ago`;
    }

    async function apiFetch(path, opts = {}) {
      const options = { headers: { 'Content-Type': 'application/json' }, ...opts };
      const resp = await fetch(path, options);
      if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
      return resp.json();
    }

    async function fetchData() {
      try {
        const data = DEMO_MODE ? demoPayload() : await apiFetch('/api/v1/get-list');
        state.data = data;
        updateTrafficSamples(data);
        render();
        renderTraffic();
      } catch (err) {
        console.warn('API error:', err.message);
      }
    }

    async function fetchPing() {
      try {
        const data = DEMO_MODE ? demoPing() : await apiFetch('/api/v1/ping-stats');
        state.ping = data;
        state.pingFetchedAt = Date.now();
        renderPing();
      } catch (err) {
        console.warn('Ping API error:', err.message);
      }
    }

    function demoPayload() {
      return {
        type: 'client',
        version: 'DEMO',
        description: 'Offline example',
        listenAddress: '0.0.0.0:4780',
        wgMtu: 1420,
        interfaces: [
          { name: 'eth0', status: 'active', senderAddress: '192.168.1.42', dstAddress: '10.0.0.1:51820', last: 2, trafficBps: 142342 },
          { name: 'usb0', status: 'active', senderAddress: '192.168.8.10', dstAddress: '10.0.0.1:51820', last: 4, trafficBps: 62344 },
          { name: 'wlan0', status: 'idle', senderAddress: '192.168.1.101', dstAddress: '10.0.0.1:51820', last: 45 },
          { name: 'wg0', status: 'excluded', senderAddress: '10.14.0.2', dstAddress: '10.0.0.1:51820', last: null }
        ]
      };
    }

    function demoPing() {
      const samples = Array.from({ length: 720 }, (_, idx) => {
        if (Math.random() < 0.03) return null;
        return 22 + Math.sin(idx / 18) * 6 + Math.random() * 4;
      });
      const values = samples.filter(v => v !== null);
      const min = Math.min(...values);
      const max = Math.max(...values);
      const avg = values.reduce((acc, v) => acc + v, 0) / values.length;
      const lost = samples.filter(v => v === null).length;
      return {
        target: '10.0.0.1',
        intervalMs: 250,
        windowMs: 180000,
        samples,
        sent: samples.length,
        lost,
        lossPercent: (lost / samples.length) * 100,
        minMs: min,
        maxMs: max,
        avgMs: avg
      };
    }

    function renderMeta(data) {
      qs('version').textContent = data.version || '—';
      qs('description').textContent = data.description || '—';
      const listen = data.listenAddress || '—';
      const wgMtu = data.wgMtu ? ` MTU: ${data.wgMtu}` : '';
      qs('listenAddress').textContent = `${listen}${wgMtu}`;
    }

    function renderCounts(list) {
      const active = list.filter(i => i.status === 'active').length;
      const excluded = list.filter(i => i.status === 'excluded').length;
      const idle = list.filter(i => i.status === 'idle').length;
      qs('activeCount').textContent = active;
      qs('excludedCount').textContent = excluded;
      qs('idleCount').textContent = idle;
    }

    function sortedAndFiltered(list) {
      const { key, dir } = state.sort;
      const mult = dir === 'asc' ? 1 : -1;
      return list.slice().sort((a,b) => {
        const av = a[key] ?? '';
        const bv = b[key] ?? '';
        if (typeof av === 'number' && typeof bv === 'number') return (av - bv) * mult;
        return av.toString().localeCompare(bv.toString()) * mult;
      });
    }

    function formatTraffic(value) {
      if (value === null || value === undefined) return '—';
      if (value >= 1024 * 1024) return `${(value / (1024 * 1024)).toFixed(1)} MB/s`;
      if (value >= 1024) return `${(value / 1024).toFixed(1)} KB/s`;
      return `${value} B/s`;
    }

    function renderInterfaceBoxes(list) {
      const activeList = qs('activeList');
      const inactiveList = qs('inactiveList');
      const excludedList = qs('excludedList');
      activeList.innerHTML = '';
      inactiveList.innerHTML = '';
      excludedList.innerHTML = '';

      if (!list.length) {
        const empty = '<div class="subtle" style="text-align:center; padding:24px;">No interfaces found</div>';
        activeList.innerHTML = empty;
        inactiveList.innerHTML = empty;
        excludedList.innerHTML = empty;
        qs('activeBadge').textContent = 0;
        qs('inactiveBadge').textContent = 0;
        qs('excludedBadge').textContent = 0;
        return;
      }

      const statusLabels = {
        active: 'Active',
        idle: 'Inactive',
        excluded: 'Excluded'
      };

      list.forEach(iface => {
        const card = document.createElement('div');
        card.className = 'iface-card';
        const traffic = iface.status === 'active' ? `
          <div class="iface-traffic">
            <span class="label">Traffic</span>
            <span class="value">${formatTraffic(iface.trafficBps)}</span>
          </div>
        ` : '';
        card.innerHTML = `
          <div class="row">
            <div class="chip"><strong>${iface.name}</strong></div>
            <span class="status ${iface.status}">${statusLabels[iface.status] || iface.status}</span>
          </div>
          <div class="row">
            <span class="label">Sender</span>
            <span class="value">${iface.senderAddress || '—'}</span>
          </div>
          <div class="row">
            <span class="label">Destination</span>
            <span class="value">${iface.dstAddress || '—'}</span>
          </div>
          <div class="row">
            <span class="label">Last packet</span>
            <span class="value">${humanizeLast(iface.last)}</span>
          </div>
          ${traffic}
          <div class="iface-actions"></div>
        `;
        const actionRow = card.querySelector('.iface-actions');
        const btn = document.createElement('button');
        btn.className = 'btn ' + (iface.status === 'excluded' ? '' : 'danger');
        btn.type = 'button';
        btn.textContent = iface.status === 'excluded' ? 'Include' : 'Exclude';
        btn.onclick = () => handleToggle(iface);
        actionRow.appendChild(btn);

        if (iface.status === 'active') {
          activeList.appendChild(card);
        } else if (iface.status === 'excluded') {
          excludedList.appendChild(card);
        } else {
          inactiveList.appendChild(card);
        }
      });

      qs('activeBadge').textContent = activeList.children.length || 0;
      qs('inactiveBadge').textContent = inactiveList.children.length || 0;
      qs('excludedBadge').textContent = excludedList.children.length || 0;
    }

    async function handleToggle(iface) {
      try {
        const path = iface.status === 'excluded' ? '/api/v1/include' : '/api/v1/exclude';
        await apiFetch(path, { method: 'POST', body: JSON.stringify({ interface: iface.name }) });
        fetchData();
      } catch (err) {
        alert(`Operation failed: ${err.message}`);
      }
    }

    function render() {
      if (!state.data) return;
      renderMeta(state.data);
      const all = state.data.interfaces || [];
      renderCounts(all);
      const list = sortedAndFiltered(all);
      renderInterfaceBoxes(list);
    }

    function updateTrafficSamples(data) {
      const now = Date.now();
      const interfaces = data.interfaces || [];
      const ifaceSpeeds = {};
      interfaces.forEach((iface) => {
        if (typeof iface.trafficBps === 'number') {
          ifaceSpeeds[iface.name] = iface.trafficBps;
          if (state.traffic.metrics.interfaces[iface.name] === undefined) {
            state.traffic.metrics.interfaces[iface.name] = true;
          }
        }
      });
      const tunnelBps = Object.values(ifaceSpeeds).reduce((sum, value) => sum + value, 0);
      state.traffic.samples.push({ timestamp: now, tunnelBps, interfaces: ifaceSpeeds });
      const cutoff = now - state.traffic.windowMs;
      while (state.traffic.samples.length && state.traffic.samples[0].timestamp < cutoff) {
        state.traffic.samples.shift();
      }
      state.trafficLog.push({ timestamp: now, tunnelBps, interfaces: ifaceSpeeds });
      if (state.trafficLog.length > 25) {
        state.trafficLog.shift();
      }
    }

    function renderTraffic() {
      renderTrafficMetrics();
      drawTrafficChart(state.traffic.samples);
      renderTrafficLog();
    }

    function renderTrafficMetrics() {
      if (!trafficMetrics) return;
      const interfaceNames = Object.keys(state.traffic.metrics.interfaces).sort();
      const rows = [];
      rows.push(metricToggle('tunnel', 'Tunnel total', getSeriesColor('tunnel'), state.traffic.metrics.tunnel));
      interfaceNames.forEach((name) => {
        rows.push(metricToggle(`iface:${name}`, name, getSeriesColor(name), state.traffic.metrics.interfaces[name]));
      });
      trafficMetrics.innerHTML = rows.join('');
      trafficMetrics.querySelectorAll('input[type="checkbox"]').forEach((input) => {
        input.addEventListener('change', () => {
          const id = input.dataset.metric;
          if (id === 'tunnel') {
            state.traffic.metrics.tunnel = input.checked;
          } else if (id.startsWith('iface:')) {
            const name = id.replace('iface:', '');
            state.traffic.metrics.interfaces[name] = input.checked;
          }
          drawTrafficChart(state.traffic.samples);
        });
      });
    }

    function metricToggle(metric, label, color, checked) {
      return `
        <label class="metric-toggle">
          <input type="checkbox" data-metric="${metric}" ${checked ? 'checked' : ''}>
          <span class="metric-swatch" style="--swatch: ${color};"></span>
          ${label}
        </label>
      `;
    }

    function getSeriesColor(key) {
      if (state.traffic.colors[key]) return state.traffic.colors[key];
      const palette = ['#7ae0ff', '#7bd88f', '#ffb86c', '#ff6b6b', '#9f7aea', '#4fd1c5', '#f6ad55'];
      const index = Object.keys(state.traffic.colors).length % palette.length;
      const color = key === 'tunnel' ? 'rgba(122,224,255,0.9)' : palette[index];
      state.traffic.colors[key] = color;
      return color;
    }

    function drawTrafficChart(samples) {
      const canvas = trafficCanvas;
      if (!canvas) return;
      const ctx = canvas.getContext('2d');
      const rect = canvas.getBoundingClientRect();
      const ratio = window.devicePixelRatio || 1;
      canvas.width = rect.width * ratio;
      canvas.height = rect.height * ratio;
      ctx.setTransform(ratio, 0, 0, ratio, 0, 0);
      ctx.clearRect(0, 0, rect.width, rect.height);

      if (!samples.length) {
        trafficEmpty.style.display = 'flex';
        trafficEmpty.textContent = 'Waiting for traffic samples…';
        trafficTooltip.style.opacity = 0;
        return;
      }

      const series = [];
      if (state.traffic.metrics.tunnel) {
        series.push({ key: 'tunnel', label: 'Tunnel total', color: getSeriesColor('tunnel'), values: samples.map(s => s.tunnelBps) });
      }
      Object.entries(state.traffic.metrics.interfaces).forEach(([name, enabled]) => {
        if (!enabled) return;
        series.push({
          key: name,
          label: name,
          color: getSeriesColor(name),
          values: samples.map(s => s.interfaces[name] ?? null)
        });
      });

      if (!series.length) {
        trafficEmpty.style.display = 'flex';
        trafficEmpty.textContent = 'No metrics selected';
        trafficTooltip.style.opacity = 0;
        return;
      }

      const values = series.flatMap(s => s.values.filter(v => v !== null && v !== undefined));
      if (!values.length) {
        trafficEmpty.style.display = 'flex';
        trafficEmpty.textContent = 'No traffic data yet';
        trafficTooltip.style.opacity = 0;
        return;
      }

      trafficEmpty.style.display = 'none';
      trafficTooltip.style.opacity = 0;

      const padding = 16;
      const width = rect.width - padding * 2;
      const height = rect.height - padding * 2;
      const max = Math.max(...values);
      const min = 0;
      const range = max - min || 1;
      const step = width / Math.max(samples.length - 1, 1);
      const yFor = (value) => padding + (max - value) / range * height;

      ctx.strokeStyle = 'rgba(255,255,255,0.08)';
      ctx.lineWidth = 1;
      for (let i = 0; i <= 4; i++) {
        const y = padding + (height / 4) * i;
        ctx.beginPath();
        ctx.moveTo(padding, y);
        ctx.lineTo(padding + width, y);
        ctx.stroke();
      }

      series.forEach((serie) => {
        ctx.strokeStyle = serie.color;
        ctx.lineWidth = 2;
        ctx.beginPath();
        let started = false;
        serie.values.forEach((value, idx) => {
          if (value === null || value === undefined) {
            started = false;
            return;
          }
          const x = padding + step * idx;
          const y = yFor(value);
          if (!started) {
            ctx.moveTo(x, y);
            started = true;
          } else {
            ctx.lineTo(x, y);
          }
        });
        ctx.stroke();
      });
    }

    function renderTrafficLog() {
      if (!trafficLog) return;
      trafficLog.innerHTML = '';
      if (!state.trafficLog.length) {
        trafficLog.innerHTML = '<div class="subtle" style="text-align:center;">No traffic samples yet</div>';
        return;
      }
      const entries = state.trafficLog.slice(-12).reverse();
      entries.forEach((entry) => {
        const row = document.createElement('div');
        row.className = 'log-entry';
        const interfaces = Object.entries(entry.interfaces || {})
          .map(([name, speed]) => `<span class="log-chip">${name}: ${formatTraffic(speed)}</span>`)
          .join(' ');
        row.innerHTML = `
          <div class="log-time">${formatTimestamp(entry.timestamp)}</div>
          <div class="log-line"><span class="log-chip">Tunnel: ${formatTraffic(entry.tunnelBps)}</span>${interfaces ? ` ${interfaces}` : ''}</div>
        `;
        trafficLog.appendChild(row);
      });
    }

    function renderPing() {
      if (!state.ping) return;
      const data = state.ping;
      qs('pingTarget').textContent = data.target || '—';
      qs('pingAvg').textContent = formatPingValue(data.avgMs);
      qs('pingMin').textContent = formatPingValue(data.minMs);
      qs('pingMax').textContent = formatPingValue(data.maxMs);
      qs('pingLoss').textContent = data.lossPercent !== undefined ? `${data.lossPercent.toFixed(1)}%` : '—';
      qs('pingLost').textContent = data.sent ? `${data.lost}/${data.sent}` : '—';
      drawPingChart(data.samples || []);
    }

    function formatPingValue(value) {
      if (value === null || value === undefined || Number.isNaN(value)) return '—';
      return `${value.toFixed(1)} ms`;
    }

    function drawPingChart(samples) {
      const canvas = pingCanvas;
      if (!canvas) return;
      const ctx = canvas.getContext('2d');
      const rect = canvas.getBoundingClientRect();
      const ratio = window.devicePixelRatio || 1;
      canvas.width = rect.width * ratio;
      canvas.height = rect.height * ratio;
      ctx.setTransform(ratio, 0, 0, ratio, 0, 0);
      ctx.clearRect(0, 0, rect.width, rect.height);

      if (!samples.length) {
        pingEmpty.style.display = 'flex';
        pingEmpty.textContent = 'Waiting for samples…';
        pingTooltip.style.opacity = 0;
        return;
      }

      const values = samples.filter(v => v !== null && v !== undefined);
      if (!values.length && state.pingMetrics.latency) {
        pingEmpty.style.display = 'flex';
        pingEmpty.textContent = 'No replies yet';
        pingTooltip.style.opacity = 0;
        return;
      }

      if (!state.pingMetrics.latency && !state.pingMetrics.loss) {
        pingEmpty.style.display = 'flex';
        pingEmpty.textContent = 'No metrics selected';
        pingTooltip.style.opacity = 0;
        return;
      }

      pingEmpty.style.display = 'none';
      pingTooltip.style.opacity = 0;

      const padding = 16;
      const width = rect.width - padding * 2;
      const height = rect.height - padding * 2;
      const safeValues = values.length ? values : [0];
      const max = Math.max(...safeValues);
      const min = Math.min(...safeValues);
      const range = max - min || 1;
      const step = width / Math.max(samples.length - 1, 1);
      const yFor = (value) => padding + (max - value) / range * height;

      ctx.strokeStyle = 'rgba(255,255,255,0.08)';
      ctx.lineWidth = 1;
      for (let i = 0; i <= 4; i++) {
        const y = padding + (height / 4) * i;
        ctx.beginPath();
        ctx.moveTo(padding, y);
        ctx.lineTo(padding + width, y);
        ctx.stroke();
      }

      if (state.pingMetrics.latency) {
        const gradient = ctx.createLinearGradient(0, padding, 0, padding + height);
        gradient.addColorStop(0, 'rgba(122,224,255,0.85)');
        gradient.addColorStop(1, 'rgba(122,224,255,0.12)');
        ctx.strokeStyle = gradient;
        ctx.lineWidth = 2;
        ctx.beginPath();
        let started = false;
        samples.forEach((value, idx) => {
          if (value === null || value === undefined) {
            started = false;
            return;
          }
          const x = padding + step * idx;
          const y = yFor(value);
          if (!started) {
            ctx.moveTo(x, y);
            started = true;
          } else {
            ctx.lineTo(x, y);
          }
        });
        ctx.stroke();
      }

      if (state.pingMetrics.loss) {
        ctx.strokeStyle = 'rgba(255,107,107,0.7)';
        ctx.lineWidth = 1;
        samples.forEach((value, idx) => {
          if (value !== null && value !== undefined) return;
          const x = padding + step * idx;
          ctx.beginPath();
          ctx.moveTo(x, padding);
          ctx.lineTo(x, padding + height);
          ctx.stroke();
        });
      }
    }

    function formatTimestamp(timestampMs) {
      const date = new Date(timestampMs);
      return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', second: '2-digit' });
    }

    function bindPingTooltip() {
      if (!pingCanvas) return;
      pingCanvas.addEventListener('mouseleave', () => {
        pingTooltip.style.opacity = 0;
      });
      pingCanvas.addEventListener('mousemove', (event) => {
        if (!state.ping || !state.ping.samples?.length || !state.pingMetrics.latency) return;
        const rect = pingCanvas.getBoundingClientRect();
        const padding = 16;
        const width = rect.width - padding * 2;
        const x = Math.min(Math.max(event.clientX - rect.left - padding, 0), width);
        const step = width / Math.max(state.ping.samples.length - 1, 1);
        const idx = Math.round(x / step);
        const sample = state.ping.samples[idx];
        const interval = state.ping.intervalMs || 250;
        const deltaMs = (state.ping.samples.length - 1 - idx) * interval;
        const baseTime = state.pingFetchedAt || Date.now();
        const timestamp = baseTime - deltaMs;
        const labelTime = formatTimestamp(timestamp);
        const labelValue = sample === null || sample === undefined ? 'loss' : `${sample.toFixed(1)} ms`;
        pingTooltip.textContent = `${labelTime} • ${labelValue}`;
        pingTooltip.style.left = `${padding + idx * step}px`;
        pingTooltip.style.top = `${padding}px`;
        pingTooltip.style.opacity = 1;
      });
    }

    function bindTrafficTooltip() {
      if (!trafficCanvas) return;
      trafficCanvas.addEventListener('mouseleave', () => {
        trafficTooltip.style.opacity = 0;
      });
      trafficCanvas.addEventListener('mousemove', (event) => {
        if (!state.traffic.samples?.length) return;
        const rect = trafficCanvas.getBoundingClientRect();
        const padding = 16;
        const width = rect.width - padding * 2;
        const x = Math.min(Math.max(event.clientX - rect.left - padding, 0), width);
        const step = width / Math.max(state.traffic.samples.length - 1, 1);
        const idx = Math.round(x / step);
        const sample = state.traffic.samples[idx];
        if (!sample) return;
        const items = [];
        if (state.traffic.metrics.tunnel) {
          items.push(`Tunnel: ${formatTraffic(sample.tunnelBps)}`);
        }
        Object.entries(state.traffic.metrics.interfaces).forEach(([name, enabled]) => {
          if (!enabled) return;
          const speed = sample.interfaces[name];
          if (speed === undefined) return;
          items.push(`${name}: ${formatTraffic(speed)}`);
        });
        const labelTime = formatTimestamp(sample.timestamp);
        trafficTooltip.textContent = `${labelTime} • ${items.join(' • ') || 'No data'}`;
        trafficTooltip.style.left = `${padding + idx * step}px`;
        trafficTooltip.style.top = `${padding}px`;
        trafficTooltip.style.opacity = 1;
      });
    }

    function scheduleAutoRefresh() {
      if (state.timer) clearInterval(state.timer);
      if (!state.auto) return;
      state.timer = setInterval(fetchData, state.interval);
    }

    function schedulePingRefresh() {
      if (state.pingTimer) clearInterval(state.pingTimer);
      state.pingTimer = setInterval(fetchPing, 1000);
    }

    // Event listeners
    qs('applyInterval').onclick = () => {
      const raw = qs('intervalInput').value.trim().toLowerCase().replace('s', '');
      const value = Number.parseInt(raw, 10);
      if (Number.isNaN(value) || value < 2 || value > 60) {
        alert('Enter a valid value between 2s and 60s.');
        return;
      }
      state.interval = value * 1000;
      qs('intervalInput').value = `${value}s`;
      scheduleAutoRefresh();
    };

    document.querySelectorAll('th[data-sort]').forEach(th => {
      th.style.cursor = 'pointer';
      th.onclick = () => {
        const key = th.dataset.sort;
        if (state.sort.key === key) {
          state.sort.dir = state.sort.dir === 'asc' ? 'desc' : 'asc';
        } else {
          state.sort = { key, dir: 'asc' };
        }
        qs('sortLabel').textContent = `${key} ${state.sort.dir === 'asc' ? '↑' : '↓'}`;
        render();
      };
    });

    // Bootstrap
    qs('intervalInput').value = `${state.interval / 1000}s`;
    fetchData();
    scheduleAutoRefresh();
    fetchPing();
    schedulePingRefresh();
    window.addEventListener('resize', () => {
      if (state.ping?.samples) drawPingChart(state.ping.samples);
      if (state.traffic?.samples) drawTrafficChart(state.traffic.samples);
    });
    const pingMetricsPanel = qs('pingMetricsPanel');
    if (pingMetricsPanel) {
      pingMetricsPanel.querySelectorAll('input[data-metric]').forEach((input) => {
        input.addEventListener('change', () => {
          state.pingMetrics[input.dataset.metric] = input.checked;
          drawPingChart(state.ping?.samples || []);
        });
      });
    }
    bindPingTooltip();
    bindTrafficTooltip();
  </script>
</body>
</html>
